apiVersion: apps/v1  
kind: Deployment      # указываем тип объекта
metadata:             
  name: web-app       # имя кластера(выбрал из задание)
spec:                 # 
  replicas: 2         # выбираем начальное кол-во подов для небольшого потребления изначально, 
                      # но в целом это не важно так как в дальнешйнем это значение будет меняться автоматом
  selector:           
    matchLabels:      
      app: web-app    # ищем все поды с меткой app=web-app

  template:           # шаблон для создания каждого пода
    metadata:         
      labels:         
        app: web-app  # метка app=web-app для идентификации

    spec:             # распределение по зонам для отказоустойчивости
      affinity:       
        podAntiAffinity:  
          preferredDuringSchedulingIgnoredDuringExecution:  # не строгое правило но с максимальной важностью 100
                                                            # не строгое правило ибо лучше работать в неидеальных условиях чем не работать вообще 
                                                            # т.к. если не выполнить строгое правило под не запустится вообще
          - weight: 100  
            podAffinityTerm:  
              labelSelector:  
                matchLabels:
                  app: web-app  # применяем ко всем подам с меткой app=web-app
              topologyKey: topology.kubernetes.io/zone  # используем стандартную метку зоны, кубер автоматически распределит поды по разным зонам
                                                        # и при падении одной зоны другие продолжат работать

          - weight: 50 # не максимальная важности ибо распределение по разным зонам вдвое важнее чем по разным нодам
                       # лучше поставить под в новую зону на занятую ноду, чем в ту же зону на свободную ноду
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  app: web-app
              topologyKey: kubernetes.io/hostname


      containers:     
      - name: web-app  # имя нашего контейнера(в примере пусть будет такое же как и имя кластера)
        image: your-web-app-image:latest  # Docker-образ, но вместо latest - тег версии
        
        ports:        
        - containerPort: 8000  # Порт, на котором работы приложения внутри контейнера чтобы знать куда отправлять трафик

        resources:    # выставляем ограничения ресурсов

          requests:   # минимальные значения
            memory: "128Mi"  # 128 мб памяти 
            cpu: "100m"     # 0.1 CPU 
                       
          limits:     # максимальные в пике
            memory: "256Mi"  # 256МБ решил взять на всякий случай, но если есть уверенность в 128 мб и есть цель сильно сэкономить то ставим 128
            cpu: "500m"     # 0.5 CPU запас для первых запросов

        # проверка готов ли принимать трафик
        readinessProbe:  
          httpGet:     # проверяем HTTP GET запрос
            path: /health  # отправляем запрос на эндпоинт /health
            port: 8000    # порт приложения
          initialDelaySeconds: 10  # делаем 10 секундный дилэй(задержку) после старта контейнера перед первой проверкой(я бы поставил чуть больше,
                                   # секунд 12 ибо в задание есть слово ОКОЛО, следовательно данные не подтвержены на 100%)
          periodSeconds: 5  # проверяем каждые 5 секунд и если проверка не удается - под не получает трафик до восстановления

# HPA
apiVersion: autoscaling/v2  # версия API для HPA
kind: HorizontalPodAutoscaler  # тип - автомасштабатор
metadata:
  name: web-app-hpa  
spec:
  scaleTargetRef:   # указываем, что мы масштабируем
    apiVersion: apps/v1  # API целевого объекта
    kind: Deployment     # тип объекта 
    name: web-app       # имя объекта
  
  minReplicas: 1    # 1 под для экономии ресурсов(во время низкой нагрузки)
  maxReplicas: 4    # 4 пода в пике

  # метрики
  metrics:          
  - type: Resource  # куда смотреть при выборе выделенных подов 
    resource:
      name: cpu     # смотрим на CPU
      target:
        type: Utilization  # используем процент использования
        averageUtilization: 70  # загрузка CPU - 70%, если CPU загрузит больше 70% добавляются поды(но макс - 4 пода), если меньше - убирает(минимум 1)

# доступ к подам извне
apiVersion: v1       # API для Service
kind: Service        # тип объекта
metadata:
  name: web-app-service  # имя сервиса
spec:
  selector:          
    app: web-app     # выбираем все поды с меткой app=web-app
  ports:          
  - port: 80         # порт принимающий входящие подключения
    targetPort: 8000 # перенаправляем трафик внутри пода